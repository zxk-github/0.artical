1. this的指向在函数定义的时候是确定不了的，只有函数执行的时候才能确定this到底指向谁
this最终指向的是那个调用它的对象(不准确)


js严格模式，this指向默认undefined
new操作符会改变this的指向问题，
function Fn() {
    this.user = 'zhang'
}
var a = new Fn();
console.log(a.user)
为什么this会指向a,因为new关键字会首先创建一个空对象，然后自动调用函数的apply方法，将this指向这个控对象，这样的函数内部的this就会被这个空对象替代


this is all about context
this 说白了就是找大佬，找拥有当前上下文的对象
大佬分为6层，层级预告权利越大，this只会认最大的

1. 世界尽头
普通就是全局浏览器环境里就是window, use strict 即使undefined

2. 找这个函数前面的点

this指向函数当前的执行环境
函数是一个单独的值，这样函数在执行的时候。就会有不同的环境执行
var f = function() {}
var obj = {f: f}

// 单独执行
f()

//obj环境执行
obj.f()

环境变量
js允许在函数体内部，引用当前环境的其他变量
var f = function() {
    console.log(x)
}
这个变量是由运行环境提供的

由于函数可以在不用的运行环境中执行，所以就需要一种机制，能够在函数体内部获取到当前的运行环境，所以就出现了this, 设计的目的就是在函数体内部指代当前函数的运行环境

this并没有引用函数的词法作用域， 的确js的引擎内对词法作用域的实现确实像一个对象，拥有属性和函数，
this和函数在哪里定义一点关系没有，和函数的执行有大大的关系
this机制的四种规则
this到底绑定或者引用的是哪个对象环境决定于函数被调用的地方，而函数的调用有不同的方式，在不同的方式中调用决定this引用的是哪个对象是有四种规则确定的

1. 默认绑定全局变量window 
function fn(){
    console.log(this.a)
}
var a = 2;
fn() // 2

2 隐式绑定
隐式调用的意思是，函数调用时拥有一个上下文对象，就好像这个函数属于该对象的一样

3. 显式绑定
bind() apply() call()
第一个参数就是上下文对象并将其赋值给this

如果传入的是一个简单类型的值，那么后台会自动转换为对应的封装对象
function fn() {
    console.log(this.a);
}
var obj = {
    a: 2
}

var a = 10;
fn.call(null)

4. new 新对象绑定
如果是一个构造函数，使用new 来调用，那么绑定的将是新创建的对象，

this是代码调用的上下文对象
this 提供了一种隐式“传递”一个对象引用的方式，可以使API设计更加简洁


this的误解 
this指向函数自身
this指向函数作用域
















